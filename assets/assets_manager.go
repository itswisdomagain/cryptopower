package assets

import (
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"decred.org/dcrwallet/v3/errors"
	"github.com/asdine/storm"
	"github.com/crypto-power/cryptopower/libwallet/utils"
	"github.com/decred/slog"
)

const (
	logFileName = "libwallet.log"

	// reservedWalletNamePrefix is the prefix for autogenerated wallet names.
	// Users cannot use a wallet name with this prefix.
	reservedWalletNamePrefix = "wallet-"
)

// AssetsManager is a tool for creating and managing different assets and their
// wallets.
type AssetsManager struct {
	rootDir string
	netType utils.NetworkType
	log     slog.Logger
	db      *storm.DB

	assetsMtx sync.RWMutex
	assets    map[AssetType]*Asset
}

func init() {
	// Set the error separator once. On init.
	errors.Separator = ":: "
}

// NewAssetsManager creates a new AssetsManager instance.
func NewAssetsManager(rootDir string, netType utils.NetworkType, supportedAssets map[AssetType]*WalletLoader) (*AssetsManager, error) {
	// Create a root dir that has the path up the network folder.
	rootDir = filepath.Join(rootDir, string(netType))
	if err := os.MkdirAll(rootDir, utils.UserFilePerm); err != nil {
		return nil, errors.Errorf("failed to create rootDir: %v", err)
	}

	backendLog, err := initLogRotator(filepath.Join(rootDir, logFileName))
	if err != nil {
		return nil, err
	}

	mgr := &AssetsManager{
		rootDir: rootDir,
		netType: netType,
		log:     backendLog.Logger("DLWL"),
	}

	mgr.assets = make(map[AssetType]*Asset, len(supportedAssets))
	for assetType, loader := range supportedAssets {
		mgr.assets[assetType] = &Asset{
			loader:  loader,
			wallets: make(map[int]*ManagedWallet),
		}
	}

	if err := mgr.initializeDatabase(); err != nil {
		return nil, err
	}

	// politeia, err := politeia.New(politeiaHost, mwDB)
	// if err != nil {
	// 	return nil, err
	// }

	// instantSwap, err := instantswap.NewInstantSwap(mwDB)
	// if err != nil {
	// 	return nil, err
	// }

	// mgr.params.DB = mwDB
	// mgr.Politeia = politeia
	// mgr.InstantSwap = instantSwap

	// // initialize the ExternalService. ExternalService provides assetsManager with
	// // the functionalities to retrieve data from 3rd party services. e.g Binance, Bittrex.
	// mgr.ExternalService = ext.NewService(mgr.chainsParams.DCR)

	// // clean all deleted wallet if exist
	// mgr.cleanDeletedWallets()

	// // Load existing wallets.
	// if err := mgr.prepareExistingWallets(); err != nil {
	// 	return nil, err
	// }

	// log.Infof("Loaded %d wallets", mgr.LoadedWalletsCount())

	// // Attempt to set the log levels if a valid db interface was found.
	// if mgr.IsAssetManagerDB() {
	// 	mgr.GetLogLevels()
	// }

	// mgr.listenForShutdown()

	return mgr, nil
}

// SupportedAssetTypes returns all asset types supported by the AssetsManager.
func (mgr *AssetsManager) SupportedAssetTypes() (assetTypes []AssetType) {
	mgr.assetsMtx.RLock()
	defer mgr.assetsMtx.RUnlock()
	for assetType := range mgr.assets {
		assetTypes = append(assetTypes, assetType)
	}
	return assetTypes
}

func (mgr *AssetsManager) WalletNameExists(walletName string) (bool, error) {
	if strings.HasPrefix(walletName, reservedWalletNamePrefix) {
		return false, errors.Errorf("wallet name cannot start with %s", reservedWalletNamePrefix)
	}
	err := mgr.db.One("Name", walletName, &ManagedWallet{})
	if err == storm.ErrNotFound { // name does not exist
		return false, nil
	}
	if err != nil { // unexpected error checking if name exists
		return false, err
	}
	return true, nil // name exists
}

func (mgr *AssetsManager) CreateNewWallet(assetType AssetType, walletName string) (*ManagedWallet, error) {
	mgr.assetsMtx.RLock()
	asset, supported := mgr.assets[assetType]
	mgr.assetsMtx.RUnlock()
	if !supported {
		return nil, errors.Errorf("asset type %s is not supported", assetType)
	}

	walletNameExists, err := mgr.WalletNameExists(walletName)
	if err != nil {
		return nil, errors.E("error checking if another wallet with the same name already exists: %v", err)
	}
	if walletNameExists {
		return nil, errors.New("another wallet with the same name already exists")
	}

	newWallet := &ManagedWallet{
		// ID: will be auto-generated on save
		Name: walletName,
		Type: assetType,
		// wallet: will be assigned below after it is actually created
	}

	err = mgr.batchDbTransaction(func(db storm.Node) error {
		err := db.Save(newWallet)
		if err != nil {
			return err
		}

		newWalletDataDir := walletDataDir(mgr.rootDir, mgr.netType, assetType, newWallet.ID)
		dirExists, err := fileExists(newWalletDataDir)
		if err != nil {
			return err
		} else if dirExists {
			newDirName, err := backupFile(newWalletDataDir, 1)
			if err != nil {
				return err
			}
			mgr.log.Infof("Undocumented file at %s moved to %s", newWalletDataDir, newDirName)
		}

		err = os.MkdirAll(newWalletDataDir, utils.UserFilePerm) // create wallet dir
		if err != nil {
			return err
		}

		if newWallet.Name == "" {
			newWallet.Name = reservedWalletNamePrefix + strconv.Itoa(newWallet.ID)
			err = db.Save(newWallet) // update db with the autogenerated name
			if err != nil {
				return err
			}
		}

		newWallet.wallet, err = asset.loader.CreateNew(mgr.netType, newWalletDataDir, "") // seed will be autogenerated
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return nil, err
	}

	mgr.assetsMtx.Lock()
	asset.wallets[newWallet.ID] = newWallet
	defer mgr.assetsMtx.Unlock()
	return newWallet, nil
}
